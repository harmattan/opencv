reflapack3 for Debian
----------------------

The lapack code itself has not been modified from the lapack source
package, version 3.0.20000531a-25.  However the blas library, against
which lapack is linked, has had backwards binary incompatible
corrections applied.  Support for the old and new API in both source
and binary form are provided to aid in the transition.  This requires
a change in package name for the lapack packages.  Please see the
documentation for the refblas3 package for details on the
modifications to the cblas API.

=============================================================================
original lapack README.Debian
=============================================================================

lapack for Debian
----------------------

These libraries were built from the 20000531 Lapack release, as
amended by applying all of the unincorporated updates listed in the
release notes (e.g. files in the patch subdirectory of the lapack
directory at netlib.)  

The new build process runs the tester binaries after
building the libraries, and collects the results in the files
/usr/share/doc/lapack/test_results.  One can search for
any failures with 'grep -i fail /usr/share/doc/lapack/test_results'.

The failures in the ?GV and ?XV tester routines are known and
expected.  The following explanation can be found at
http://www.netlib.org/lapack/html/installation.hints:

    The only known testing failures are in condition number estimation
    routines in the generalized nonsymmetric eigenproblem testing.
    Specifically in sgd.out, dgd.out, cgd.out and zgd.out. The cause for
    the failures of some test cases is that the mathematical algorithm
    used for estimating the condition numbers could over- or
    under-estimate the true values in a certain factor in some rare cases.
    Further details can be found in LAPACK Working Note 87.

This version of lapack also introduces a few testing errors in the
single precision real symmetric and complex Hermitian eigenvalue
routines, at least on ix86 platforms.  Correspondence regarding this
issue with the lapack upstream authors follows at the end of this
file.  Suffice it to say that there is no known solution at present,
but that the errors should be confined to loss of at most 2-3 decimal
places of precision in the routine results.  For this reason, Debian
also supplies lapack libraries based on the earlier release in the
lapack99 package, which, though having errors of its own, does not
exhibit this particular failing.

=============================================================================

From: Camm Maguire <camm@enhanced.com>
Subject: Re: New Debian maintainer
To: Susan Blackford <susan@myri.com>
cc: camm@enhanced.com
Date: 15 Nov 2001 15:33:11 -0500
Received: from intech19.enhanced.com [192.168.2.19] (mail)
	by intech5.enhanced.com with esmtp (Exim 3.12 #1 (Debian))
	id 164TCL-0005qT-00; Thu, 15 Nov 2001 15:33:21 -0500
Received: from camm by intech19.enhanced.com with local (Exim 3.12 #1 (Debian))
	id 164TCB-0002gL-00; Thu, 15 Nov 2001 15:33:11 -0500
References: <E163L4N-0003Xf-00@intech19.enhanced.com> <01111312052804.00517@idefix>
In-Reply-To: Susan Blackford's message of "Tue, 13 Nov 2001 12:05:28 -0500"
Message-ID: <547ksrdbaw.fsf@intech19.enhanced.com>
X-Mailer: Gnus v5.7/Emacs 20.7
X-UIDL: 9358c79a10286a739f7134b4a7627355
Lines: 92
Xref: intech19.enhanced.com mail.camm:27060

Greetings, and thanks for your reply!

Susan Blackford <susan@myri.com> writes:

> Hi,
> 
> If the LIN timers (or any of the testers/timers) dies when loading,
> then you should reduce the size of NMAX in the=20
>    LAPACK/TESTING/LIN/*chkaa.f
>    LAPACK/TESTING/EIG/*chkee.f
>    LAPACK/TIMING/LIN/*timaa.f
>    LAPACK/TIMING/EIG/*timee.f
> 

Thanks for this.  I read a usenet post indicating that MAXVAL could be
reduced to 7 or 8 in the ?timaa.f, and this seems to work too.  Is
either solution acceptable?

Secondarily, I'm upgrading the package from the 1999 3.0 to the
latest, plus the unincorporated patches listed on the release note
pages.

With the old version, I just get the expected _gd.out errors on test,
but the new version has a few errors in the symmetric eigenroutine
single and complex precision as well (_sep.out):

1999:
=============================================================================
cgd.out: CGV drivers:      4 out of   1092 tests failed to pass the threshold
cgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when reordering fails
cgd.out: CGX drivers:      6 out of   1500 tests failed to pass the threshold
dgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when reordering fails
dgd.out: SGX drivers:      6 out of   1500 tests failed to pass the threshold
dgd.out: DXV drivers:    200 out of   5000 tests failed to pass the threshold
dtest.out: DLS drivers:   2250 out of  65268 tests failed to pass the threshold
sgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when reordering fails
sgd.out: SGX drivers:      8 out of   1500 tests failed to pass the threshold
sgd.out: SXV drivers:     37 out of   5000 tests failed to pass the threshold
zgd.out: ZGV drivers:      4 out of   1092 tests failed to pass the threshold
zgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when reordering fails
zgd.out: CGX drivers:      6 out of   1500 tests failed to pass the threshold
zgd.out: ZXV drivers:     24 out of   5000 tests failed to pass the threshold

latest:
=============================================================================
cgd.out: CGV drivers:      4 out of   1092 tests failed to pass the threshold
csep.out: CST:    1 out of  4662 tests failed to pass the threshold
csep.out: CST drivers:      1 out of  11664 tests failed to pass the threshold
csep.out: CST:    1 out of  4662 tests failed to pass the threshold
dgd.out: DXV drivers:    200 out of   5000 tests failed to pass the threshold
sgd.out: SXV drivers:     37 out of   5000 tests failed to pass the threshold
ssep.out: SST:    1 out of  4662 tests failed to pass the threshold
ssep.out: SST drivers:      1 out of  14256 tests failed to pass the threshold
zgd.out: ZGV drivers:      4 out of   1092 tests failed to pass the threshold
zgd.out: ZXV drivers:     24 out of   5000 tests failed to pass the threshold
=============================================================================

I am somewhat hesitant to introduce these new errors into the official
lib of the Debian distribution.  I've seen these errors reported in
the release_notes in similar setups to mine (g77 2.95, Linux, PIII).
The latest lib was compiled with the suggested flags in the Linux
make.inc in INSTALL (-funroll-all-loops -O3), whereas the older
version was compiled with (-funroll-all-loops -O3 -fomit-frame-pointer
-ff90).  I can't imagine that the omission of optimizing flags could
introduce new errors, but am willing to recompile with the old
settings if you think this would help.

Any advice appreciated!



> > 3)  Is this also the place to submit patches/suggestions?
> 
> Yes, absolutely... :)
> 
> Susan
> 
> 
> --=20
> ---------------------------------------------
> Susan Blackford
> Member of Technical Staff
> Myricom, Inc.
> ---------------------------------------------
> 
> 

-- 
Camm Maguire			     			camm@enhanced.com
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah

=============================================================================

From: Edward Anderson <Anderson.Edward@epa.gov>
Subject: Re: New Debian maintainer
To: camm@enhanced.com
CC: Susan Blackford <susan@cs.utk.edu>
Date: Mon, 26 Nov 2001 09:51:48 -0500
Organization: Lockheed Martin (contractor to the U.S. EPA)
Received: from localhost [127.0.0.1] (root)
	by intech5.enhanced.com with esmtp (Exim 3.12 #1 (Debian))
	id 168N8I-0001aM-00; Mon, 26 Nov 2001 09:53:18 -0500
Received: from 204.213.252.11
	by localhost with POP3 (fetchmail-5.3.3)
	for camm@enhanced.com (multi-drop); Mon, 26 Nov 2001 09:53:18 -0500 (EST)
Received: from mail.eticomm.net [204.213.252.17] 
	by ux1.cyberenet.net with esmtp (Exim 1.61 #1)
	id 168N7M-0002gE-00; Mon, 26 Nov 2001 09:52:20 -0500
Received: from [134.67.64.25] (helo=nesc.epa.gov)
	by relay.eticomm.net with esmtp (Exim 3.33 #2)
	id 168N7M-000CuP-00
	for camm@enhanced.com; Mon, 26 Nov 2001 09:52:20 -0500
Received: from epa.gov (yew.nesc.epa.gov [134.67.64.48])
	by nesc.epa.gov (8.9.3+Sun/8.9.1) with ESMTP id JAA17204;
	Mon, 26 Nov 2001 09:51:49 -0500 (EST)
Sender: dle@nesc.epa.gov
Message-ID: <3C025704.86683917@epa.gov>
X-Mailer: Mozilla 4.75C-SGI [en] (X11; I; IRIX 6.5 IP32)
X-Accept-Language: en
MIME-Version: 1.0
References: <004701c17372$2a3580e0$2fee80ac@compaq>
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-UIDL: 11a1ca53c0909d8b833a35f7beea5f16
Lines: 167
Xref: intech19.enhanced.com mail.camm:27339

Camm:

I have my own version of LAPACK which incorporates some changes not yet
in the netlib version.  It's hard to say which if any of these might fix
the errors you are seeing.  But if you could send me the full text of
the output files containing tests that are failing, I may have a few
suggestions for you.

   --Ed Anderson

Ed Anderson wrote:
> 
> ----- Original Message -----
> From: Camm Maguire <camm@enhanced.com>
> To: <lapack@cs.utk.edu>
> Sent: Monday, November 19, 2001 5:05 PM
> Subject: [Camm Maguire <camm@enhanced.com>] Re: New Debian maintainer
> 
> > Susan--
> >
> > Resending this to the lapack address, as I haven't heard back
> > from my direct reply to you.  Any advice most appreciated!
> >
> > Take care,
> > --
> > Camm Maguire      camm@enhanced.com
> > ==========================================================================
> > "The earth is but one country, and mankind its citizens."  --  Baha'u'llah
> > ------- Start of forwarded message -------
> > To: Susan Blackford <susan@myri.com>
> > cc: camm@enhanced.com
> > Subject: Re: New Debian maintainer
> > References: <E163L4N-0003Xf-00@intech19.enhanced.com>
> <01111312052804.00517@idefix>
> > From: Camm Maguire <camm@enhanced.com>
> > Date: 15 Nov 2001 15:33:11 -0500
> > Message-ID: <547ksrdbaw.fsf@intech19.enhanced.com>
> >
> > Greetings, and thanks for your reply!
> >
> > Susan Blackford <susan@myri.com> writes:
> >
> > > Hi,
> > >
> > > If the LIN timers (or any of the testers/timers) dies when loading,
> > > then you should reduce the size of NMAX in the=20
> > >    LAPACK/TESTING/LIN/*chkaa.f
> > >    LAPACK/TESTING/EIG/*chkee.f
> > >    LAPACK/TIMING/LIN/*timaa.f
> > >    LAPACK/TIMING/EIG/*timee.f
> > >
> >
> > Thanks for this.  I read a usenet post indicating that MAXVAL could be
> > reduced to 7 or 8 in the ?timaa.f, and this seems to work too.  Is
> > either solution acceptable?
> >
> > Secondarily, I'm upgrading the package from the 1999 3.0 to the
> > latest, plus the unincorporated patches listed on the release note
> > pages.
> >
> > With the old version, I just get the expected _gd.out errors on test,
> > but the new version has a few errors in the symmetric eigenroutine
> > single and complex precision as well (_sep.out):
> >
> > 1999:
> >
> ============================================================================
> =
> > cgd.out: CGV drivers:      4 out of   1092 tests failed to pass the
> threshold
> > cgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when
> reordering fails
> > cgd.out: CGX drivers:      6 out of   1500 tests failed to pass the
> threshold
> > dgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when
> reordering fails
> > dgd.out: SGX drivers:      6 out of   1500 tests failed to pass the
> threshold
> > dgd.out: DXV drivers:    200 out of   5000 tests failed to pass the
> threshold
> > dtest.out: DLS drivers:   2250 out of  65268 tests failed to pass the
> threshold
> > sgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when
> reordering fails
> > sgd.out: SGX drivers:      8 out of   1500 tests failed to pass the
> threshold
> > sgd.out: SXV drivers:     37 out of   5000 tests failed to pass the
> threshold
> > zgd.out: ZGV drivers:      4 out of   1092 tests failed to pass the
> threshold
> > zgd.out:  9 = 1/ULP  if DIFEST <> 0 or DIFTRU > ULP*norm(A,B) when
> reordering fails
> > zgd.out: CGX drivers:      6 out of   1500 tests failed to pass the
> threshold
> > zgd.out: ZXV drivers:     24 out of   5000 tests failed to pass the
> threshold
> >
> > latest:
> >
> ============================================================================
> =
> > cgd.out: CGV drivers:      4 out of   1092 tests failed to pass the
> threshold
> > csep.out: CST:    1 out of  4662 tests failed to pass the threshold
> > csep.out: CST drivers:      1 out of  11664 tests failed to pass the
> threshold
> > csep.out: CST:    1 out of  4662 tests failed to pass the threshold
> > dgd.out: DXV drivers:    200 out of   5000 tests failed to pass the
> threshold
> > sgd.out: SXV drivers:     37 out of   5000 tests failed to pass the
> threshold
> > ssep.out: SST:    1 out of  4662 tests failed to pass the threshold
> > ssep.out: SST drivers:      1 out of  14256 tests failed to pass the
> threshold
> > zgd.out: ZGV drivers:      4 out of   1092 tests failed to pass the
> threshold
> > zgd.out: ZXV drivers:     24 out of   5000 tests failed to pass the
> threshold
> >
> ============================================================================
> =
> >
> > I am somewhat hesitant to introduce these new errors into the official
> > lib of the Debian distribution.  I've seen these errors reported in
> > the release_notes in similar setups to mine (g77 2.95, Linux, PIII).
> > The latest lib was compiled with the suggested flags in the Linux
> > make.inc in INSTALL (-funroll-all-loops -O3), whereas the older
> > version was compiled with (-funroll-all-loops -O3 -fomit-frame-pointer
> > -ff90).  I can't imagine that the omission of optimizing flags could
> > introduce new errors, but am willing to recompile with the old
> > settings if you think this would help.
> >
> > Any advice appreciated!
> >
> >
> >
> > > > 3)  Is this also the place to submit patches/suggestions?
> > >
> > > Yes, absolutely... :)
> > >
> > > Susan
> > >
> > >
> > > --=20
> > > ---------------------------------------------
> > > Susan Blackford
> > > Member of Technical Staff
> > > Myricom, Inc.
> > > ---------------------------------------------
> > >
> > >
> >
> > --
> > Camm Maguire      camm@enhanced.com
> > ==========================================================================
> > "The earth is but one country, and mankind its citizens."  --  Baha'u'llah
> >
> > ------- End of forwarded message -------

----------------------------------------------------------------
Ed Anderson
Scientific Applications Consultant
Lockheed Martin Technology Services (contractor to the U.S. EPA)
Phone: 919-541-0299
mailto:Anderson.Edward@epa.gov

=============================================================================

From: Edward Anderson <Anderson.Edward@epa.gov>
Subject: Re: New Debian maintainer
To: Camm Maguire <camm@enhanced.com>
CC: Edward Anderson <Anderson.Edward@epamail.epa.gov>,
        Susan Blackford <susan@cs.utk.edu>
Date: Fri, 30 Nov 2001 10:30:36 -0500
Organization: Lockheed Martin (contractor to the U.S. EPA)
Received: from localhost [127.0.0.1] (root)
	by intech5.enhanced.com with esmtp (Exim 3.12 #1 (Debian))
	id 169peX-0001br-00; Fri, 30 Nov 2001 10:32:37 -0500
Received: from 204.213.252.11
	by localhost with POP3 (fetchmail-5.3.3)
	for camm@enhanced.com (multi-drop); Fri, 30 Nov 2001 10:32:37 -0500 (EST)
Received: from mail.eticomm.net [204.213.252.17] 
	by ux1.cyberenet.net with esmtp (Exim 1.61 #1)
	id 169pd6-0002EM-00; Fri, 30 Nov 2001 10:31:08 -0500
Received: from linden.nesc.epa.gov ([134.67.64.25] helo=nesc.epa.gov)
	by relay.eticomm.net with esmtp (Exim 3.33 #2)
	id 169pd5-0003vM-00
	for camm@enhanced.com; Fri, 30 Nov 2001 10:31:07 -0500
Received: from epa.gov (yew.nesc.epa.gov [134.67.64.48])
	by nesc.epa.gov (8.9.3+Sun/8.9.1) with ESMTP id KAA14465;
	Fri, 30 Nov 2001 10:30:36 -0500 (EST)
Sender: dle@nesc.epa.gov
Message-ID: <3C07A61C.57A40172@epa.gov>
X-Mailer: Mozilla 4.75C-SGI [en] (X11; I; IRIX 6.5 IP32)
X-Accept-Language: en
MIME-Version: 1.0
References: <004701c17372$2a3580e0$2fee80ac@compaq> <3C025704.86683917@epa.gov> <544rndhvce.fsf@intech19.enhanced.com>
Content-Type: multipart/mixed;
 boundary="------------6C386FC925298A0C59F101F0"
X-UIDL: 7119754484cd74abeaed169b5c841fe4
Lines: 770
Xref: intech19.enhanced.com mail.camm:27462

This is a multi-part message in MIME format.
--------------6C386FC925298A0C59F101F0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

Camm Maguire wrote:
> 
> Greetings!  Sorry to bother you again -- just wondering if you got my
> last reply regarding the netlib blas being used, and might have any
> suggestions for things I could try.
> 
> Take care, and thanks again,
> --
> Camm Maguire                                            camm@enhanced.com
> ==========================================================================
> "The earth is but one country, and mankind its citizens."  --  Baha'u'llah

Camm,

Sorry for the slow response.  I've looked at your failing tests, and the
test ratios are all relatively small.  This usually means a loss of
orthogonality or improper scaling that causes underflow, which most
often occurs in a situation where a sum of squares is required.  Besides
the obvious cases where you are taking a 2-norm of a vector or the
Frobenius norm of a matrix, it can also occur any time you divide by a
complex number.  LAPACK has auxiliary routines for doing a scaled
complex divide (CLADIV) and for taking the square root of a sum of
squares of two or three numbers (SLAPY2 and SLAPY3), but scaling errors
keep cropping up when new software is introduced, and even these
auxiliary routines aren't as safe as they should be.

The biggest offenders are the 2-norm routines SNRM2, SCNRM2, DNRM2, and
DZNRM2.  The original netlib routine had some difficult to follow code
(known as "Blue's algorithm"); unfortunately it was so hard to
understand that most vendors implemented their own version, and got the
scaling wrong.  A few years ago, the netlib version was replaced with
one based on LAPACK's SLASSQ, and they got the scaling wrong too.  You
can find some more description of these problems in my online technical
report, "Installing LAPACK 3 on CRAY machines",
http://www.cs.utk.edu/~eanderso/lapack3.html.  I am working on an
updated version more suitable to IEEE arithmetic machines with gradual
underflow, using the IBM SP at my site as a test bed.

To see if the 2-norms may be at fault, I will attach prototypes of my
latest xLASSQ versions and associated BLAS that I have tested on an IBM
SP.  I would like to hard code all the scaling constants in xLASSQ for
speed but compute them in this version.  If this doesn't help, then you
may need a larger set of changes, either from a future LAPACK release or
my IBM SP patch when it is ready.

   --Ed Anderson

----------------------------------------------------------------
Ed Anderson
Scientific Applications Consultant
Lockheed Martin Technology Services (contractor to the U.S. EPA)
Phone: 919-541-0299
mailto:Anderson.Edward@epa.gov
--------------6C386FC925298A0C59F101F0
Content-Type: text/plain; charset=us-ascii;
 name="tocamm"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="tocamm"

      SUBROUTINE SLASSQ( N, X, INCX, SCL, SUMSQ )
!
!  -- LAPACK auxiliary routine (version 2.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!     10-15-99:  New version based on LAWN 126 (eca)
!     08-31-01:  Use smaller constants for 32-bit IEEE (eca)
!     09-25-01:  Don't scale by < SAFMIN or more than SAFMAX (eca)
!
!     .. Scalar Arguments ..
      INTEGER            INCX, N
      REAL               SCL, SUMSQ
!     ..
!     .. Array Arguments ..
      REAL               X( * )
!     ..
!
!  Purpose
!  =======
!
!  SLASSQ  returns the values  scl  and  smsq  such that
!
!     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
!
!  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
!  assumed to be non-negative and  scl  returns the value
!
!     scl = max( scale, abs( x( i ) ) ).
!
!  scale and sumsq must be supplied in SCL and SUMSQ and
!  scl and smsq are overwritten on SCL and SUMSQ respectively.
!
!  Arguments
!  =========
!
!  N       (input) INTEGER
!          The number of elements to be used from the vector X.
!
!  X       (input) REAL array, dimension (N)
!          The vector for which a scaled sum of squares is computed.
!             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
!
!  INCX    (input) INTEGER
!          The increment between successive values of the vector X.
!          INCX > 0.
!
!  SCL     (input/output) REAL
!          On entry, the value  scale  in the equation above.
!          On exit, SCL is overwritten with  scl , the scaling factor
!          for the sum of squares.
!
!  SUMSQ   (input/output) REAL
!          On entry, the value  sumsq  in the equation above.
!          On exit, SUMSQ is overwritten with  smsq , the basic sum of
!          squares from which  scl  has been factored out.
!
! =====================================================================
!
      REAL ONE, ZERO
      PARAMETER ( ONE = 1.0E0, ZERO = 0.0E0 )
      INTEGER I, IX, IX2
      REAL CUTHI, CUTLO, HITEST, SAFMAX, SAFMIN, SMAX, SQMAX
      INTRINSIC ABS, EPSILON, MAX, REAL, TINY
      DATA CUTLO / 1.0E-15 /
      DATA CUTHI / 1.0E+19 /

      IF( N.LE.0 ) RETURN
      HITEST = CUTHI / REAL( N+1 )
!eca  SAFMIN = SLAMCH( 'Safe minimum' ) / SLAMCH( 'Epsilon' )
      SAFMIN = TINY( ONE ) / EPSILON( ONE )
      SAFMAX = ONE / SAFMIN
      IF( SUMSQ.EQ.ZERO ) SCL = ONE

      IF( INCX.EQ.1 ) THEN
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(X(I)) )
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            DO I = 1, N
               SUMSQ = SUMSQ + X(I)**2
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            DO I = 1, N
               SUMSQ = SUMSQ + ( X(I) / SCL )**2
            END DO
         END IF
      ELSE
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         IX = 1
         IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(X(IX)) )
            IX = IX + INCX
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + X(IX)**2
               IX = IX + INCX
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + ( X(IX) / SCL )**2
               IX = IX + INCX
            END DO
         END IF
      END IF
      RETURN
      END
      SUBROUTINE CLASSQ( N, X, INCX, SCL, SUMSQ )
!
!  -- LAPACK auxiliary routine (version 2.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!     10-15-99:  New version based on LAWN 126 (eca)
!     08-31-01:  Use smaller constants for 32-bit IEEE (eca)
!     09-25-01:  Don't scale by < SAFMIN or more than SAFMAX (eca)
!
!     .. Scalar Arguments ..
      INTEGER            INCX, N
      REAL               SCL, SUMSQ
!     ..
!     .. Array Arguments ..
      COMPLEX            X( * )
!     ..
!
!  Purpose
!  =======
!
!  CLASSQ returns the values scl and ssq such that
!
!     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
!
!  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
!  assumed to be non-negative and scl returns the value
!
!     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
!            i
!
!  scale and sumsq must be supplied in SCL and SUMSQ respectively.
!  SCL and SUMSQ are overwritten by scl and ssq respectively.
!
!  Arguments
!  =========
!
!  N       (input) INTEGER
!          The number of elements to be used from the vector X.
!
!  X       (input) COMPLEX array, dimension (N)
!          The vector x as described above.
!             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
!
!  INCX    (input) INTEGER
!          The increment between successive values of the vector X.
!          INCX > 0.
!
!  SCL     (input/output) REAL
!          On entry, the value  scale  in the equation above.
!          On exit, SCALE is overwritten with the value  scl .
!
!  SUMSQ   (input/output) REAL
!          On entry, the value  sumsq  in the equation above.
!          On exit, SUMSQ is overwritten with the value  ssq .
!
! =====================================================================
!
      REAL ONE, ZERO
      PARAMETER ( ONE = 1.0E0, ZERO = 0.0E0 )
      INTEGER I, IX, IX2
      REAL CUTHI, CUTLO, HITEST, SAFMAX, SAFMIN, SMAX, SQMAX
      INTRINSIC ABS, EPSILON, MAX, REAL, TINY
      DATA CUTLO / 1.0E-15 /
      DATA CUTHI / 1.0E+19 /

      IF( N.LE.0 ) RETURN
      HITEST = CUTHI / REAL( 2*N+1 )
!eca  SAFMIN = SLAMCH( 'Safe minimum' ) / SLAMCH( 'Epsilon' )
      SAFMIN = TINY( ONE ) / EPSILON( ONE )
      SAFMAX = ONE / SAFMIN
      IF( SUMSQ.EQ.ZERO ) SCL = ONE

      IF( INCX.EQ.1 ) THEN
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(REAL(X(I))), ABS(AIMAG(X(I))) )
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            DO I = 1, N
               SUMSQ = SUMSQ + REAL(X(I))**2 + AIMAG(X(I))**2
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            DO I = 1, N
               SUMSQ = SUMSQ + ( REAL(X(I)) / SCL )**2 +
     &                 ( AIMAG(X(I)) / SCL )**2
            END DO
         END IF
      ELSE
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         IX = 1
         IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(REAL(X(IX))), ABS(AIMAG(X(IX))) )
            IX = IX + INCX
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + REAL(X(IX))**2 + AIMAG(X(IX))**2
               IX = IX + INCX
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + ( REAL(X(IX)) / SCL )**2 +
     &                 ( AIMAG(X(IX)) / SCL )**2
               IX = IX + INCX
            END DO
         END IF
      END IF
      RETURN
      END
      SUBROUTINE DLASSQ( N, X, INCX, SCL, SUMSQ )
!
!  -- LAPACK auxiliary routine (version 2.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!     10-15-99:  New version based on LAWN 126 (eca)
!     09-25-01:  Don't scale by < SAFMIN or more than SAFMAX (eca)
!
!     .. Scalar Arguments ..
      INTEGER            INCX, N
      DOUBLE PRECISION   SCL, SUMSQ
!     ..
!     .. Array Arguments ..
      DOUBLE PRECISION   X( * )
!     ..
!
!  Purpose
!  =======
!
!  DLASSQ  returns the values  scl  and  smsq  such that
!
!     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
!
!  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
!  assumed to be non-negative and  scl  returns the value
!
!     scl = max( scale, abs( x( i ) ) ).
!
!  scale and sumsq must be supplied in SCL and SUMSQ and
!  scl and smsq are overwritten on SCL and SUMSQ respectively.
!
!  Arguments
!  =========
!
!  N       (input) INTEGER
!          The number of elements to be used from the vector X.
!
!  X       (input) DOUBLE PRECISION array, dimension (N)
!          The vector for which a scaled sum of squares is computed.
!             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
!
!  INCX    (input) INTEGER
!          The increment between successive values of the vector X.
!          INCX > 0.
!
!  SCL     (input/output) DOUBLE PRECISION
!          On entry, the value  scale  in the equation above.
!          On exit, SCL is overwritten with  scl , the scaling factor
!          for the sum of squares.
!
!  SUMSQ   (input/output) DOUBLE PRECISION
!          On entry, the value  sumsq  in the equation above.
!          On exit, SUMSQ is overwritten with  smsq , the basic sum of
!          squares from which  scl  has been factored out.
!
! =====================================================================
!
      DOUBLE PRECISION ONE, ZERO
      PARAMETER ( ONE = 1.0D0, ZERO = 0.0D0 )
      INTEGER I, IX, IX2
      DOUBLE PRECISION CUTHI, CUTLO, HITEST, SAFMAX, SAFMIN, SMAX, SQMAX
      INTRINSIC ABS, MAX, DBLE, EPSILON, SQRT, TINY
      DATA CUTLO / 1.00104154759155046D-146 /
      DATA CUTHI / 9.48075190810917589D+153 /

      IF( N.LE.0 ) RETURN
      HITEST = CUTHI / DBLE( N+1 )
!eca  SAFMIN = DLAMCH( 'Safe minimum' ) / DLAMCH( 'Epsilon' )
      SAFMIN = TINY( ONE ) / EPSILON( ONE )
      SAFMAX = ONE / SAFMIN
      IF( SUMSQ.EQ.ZERO ) SCL = ONE

      IF( INCX.EQ.1 ) THEN
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(X(I)) )
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            DO I = 1, N
               SUMSQ = SUMSQ + X(I)**2
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            DO I = 1, N
               SUMSQ = SUMSQ + ( X(I) / SCL )**2
            END DO
         END IF
      ELSE
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         IX = 1
         IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(X(IX)) )
            IX = IX + INCX
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + X(IX)**2
               IX = IX + INCX
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + ( X(IX) / SCL )**2
               IX = IX + INCX
            END DO
         END IF
      END IF
      RETURN
      END
      SUBROUTINE ZLASSQ( N, X, INCX, SCL, SUMSQ )
!
!  -- LAPACK auxiliary routine (version 2.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!     10-15-99:  New version based on LAWN 126 (eca)
!     09-25-01:  Don't scale by < SAFMIN or more than SAFMAX (eca)
!
!     .. Scalar Arguments ..
      INTEGER            INCX, N
      DOUBLE PRECISION   SCL, SUMSQ
!     ..
!     .. Array Arguments ..
      COMPLEX*16         X( * )
!     ..
!
!  Purpose
!  =======
!
!  ZLASSQ returns the values scl and ssq such that
!
!     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
!
!  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
!  assumed to be non-negative and scl returns the value
!
!     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
!            i
!
!  scale and sumsq must be supplied in SCL and SUMSQ respectively.
!  SCL and SUMSQ are overwritten by scl and ssq respectively.
!
!  Arguments
!  =========
!
!  N       (input) INTEGER
!          The number of elements to be used from the vector X.
!
!  X       (input) COMPLEX*16 array, dimension (N)
!          The vector x as described above.
!             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
!
!  INCX    (input) INTEGER
!          The increment between successive values of the vector X.
!          INCX > 0.
!
!  SCL     (input/output) DOUBLE PRECSION
!          On entry, the value  scale  in the equation above.
!          On exit, SCALE is overwritten with the value  scl .
!
!  SUMSQ   (input/output) DOUBLE PRECSION
!          On entry, the value  sumsq  in the equation above.
!          On exit, SUMSQ is overwritten with the value  ssq .
!
! =====================================================================
!
      DOUBLE PRECISION ONE, ZERO
      PARAMETER ( ONE = 1.0D0, ZERO = 0.0D0 )
      INTEGER I, IX, IX2
      DOUBLE PRECISION CUTHI, CUTLO, HITEST, SAFMAX, SAFMIN, SMAX, SQMAX
      INTRINSIC ABS, MAX, DBLE, EPSILON, SQRT, TINY
      DATA CUTLO / 1.00104154759155046D-146 /
      DATA CUTHI / 9.48075190810917589D+153 /

      IF( N.LE.0 ) RETURN
      HITEST = CUTHI / DBLE( 2*N+1 )
!eca  SAFMIN = DLAMCH( 'Safe minimum' ) / DLAMCH( 'Epsilon' )
      SAFMIN = TINY( ONE ) / EPSILON( ONE )
      SAFMAX = ONE / SAFMIN
      IF( SUMSQ.EQ.ZERO ) SCL = ONE

      IF( INCX.EQ.1 ) THEN
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(DBLE(X(I))), ABS(DIMAG(X(I))) )
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            DO I = 1, N
               SUMSQ = SUMSQ + DBLE(X(I))**2 + DIMAG(X(I))**2
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            DO I = 1, N
               SUMSQ = SUMSQ + ( DBLE(X(I)) / SCL )**2 +
     &                 ( DIMAG(X(I)) / SCL )**2
            END DO
         END IF
      ELSE
!
!        Pass through once to find the maximum value in X.
!
         SMAX = ZERO
         IX = 1
         IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
         DO I = 1, N
            SMAX = MAX( SMAX, ABS(DBLE(X(IX))), ABS(DIMAG(X(IX))) )
            IX = IX + INCX
         END DO
         SQMAX = MAX( SCL*SQRT( SUMSQ ), SMAX )
!
         IF( SCL.EQ.ONE .AND. SQMAX.GT.CUTLO .AND. SQMAX.LT.HITEST )
     &      THEN
!
!           If SCL = ONE and SQMAX is greater than CUTLO and less than
!           HITEST, no scaling should be needed.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + DBLE(X(IX))**2 + DIMAG(X(IX))**2
               IX = IX + INCX
            END DO
         ELSE IF( SMAX.GT.ZERO ) THEN
!
!           Scale by SQMAX if SCL = ONE, otherwise scale by
!           max( SQMAX, SCL ).
!
            SQMAX = MIN( MAX( SQMAX, SAFMIN ), SAFMAX )
            IF( SCL.EQ.ONE .OR. SCL.LT.SQMAX ) THEN
               SUMSQ = ( SUMSQ*( SCL / SQMAX ) )*( SCL / SQMAX )
               SCL = SQMAX
            END IF
!
!           Add the sum of squares of values of X scaled by SCL.
!
            IX = 1
            IF( INCX.LT.0 ) IX = 1 - (N-1)*INCX
            DO I = 1, N
               SUMSQ = SUMSQ + ( DBLE(X(IX)) / SCL )**2 +
     &                 ( DIMAG(X(IX)) / SCL )**2
               IX = IX + INCX
            END DO
         END IF
      END IF
      RETURN
      END
      real function SNRM2( n, x, incx ) 
!
!  -- Level 1 BLAS --
!     E. Anderson, NESC
!     November 17, 1999
!
      integer n, incx
      real x(*)
      real scl, sumsq
      external SLASSQ
      intrinsic SQRT
      scl = 1.0
      sumsq = 0.0
      call SLASSQ( n, x, incx, scl, sumsq )
      SNRM2 = scl*SQRT( sumsq )
      return
      end
      real function SCNRM2( n, x, incx ) 
!
!  -- Level 1 BLAS --
!     E. Anderson, NESC
!     November 17, 1999
!
      integer n, incx
      complex x(*)
      real scl, sumsq
      external CLASSQ
      intrinsic SQRT
      scl = 1.0
      sumsq = 0.0
      call CLASSQ( n, x, incx, scl, sumsq )
      SCNRM2 = scl*SQRT( sumsq )
      return
      end
      double precision function DNRM2( n, x, incx ) 
!
!  -- Level 1 BLAS --
!     E. Anderson, NESC
!     November 17, 1999
!
      integer n, incx
      double precision x(*)
      double precision scl, sumsq
      external DLASSQ
      intrinsic DSQRT
      scl = 1.0D0
      sumsq = 0.0D0
      call DLASSQ( n, x, incx, scl, sumsq )
      DNRM2 = scl*DSQRT( sumsq )
      return
      end
      double precision function DZNRM2( n, x, incx ) 
!
!  -- Level 1 BLAS --
!     E. Anderson, NESC
!     November 17, 1999
!
      integer n, incx
      complex*16 x(*)
      double precision scl, sumsq
      external ZLASSQ
      intrinsic DSQRT
      scl = 1.0D0
      sumsq = 0.0D0
      call ZLASSQ( n, x, incx, scl, sumsq )
      DZNRM2 = scl*DSQRT( sumsq )
      return
      end

--------------6C386FC925298A0C59F101F0--

=============================================================================

From: Edward Anderson <Anderson.Edward@epa.gov>
Subject: Re: New Debian maintainer
To: Camm Maguire <camm@enhanced.com>
Date: Mon, 03 Dec 2001 08:42:42 -0500
Organization: Lockheed Martin (contractor to the U.S. EPA)
Received: from localhost [127.0.0.1] (root)
	by intech5.enhanced.com with esmtp (Exim 3.12 #1 (Debian))
	id 16AtPH-0000Jg-00; Mon, 03 Dec 2001 08:45:15 -0500
Received: from 204.213.252.11
	by localhost with POP3 (fetchmail-5.3.3)
	for camm@enhanced.com (multi-drop); Mon, 03 Dec 2001 08:45:15 -0500 (EST)
Received: from mail.eticomm.net [204.213.252.17] 
	by ux1.cyberenet.net with esmtp (Exim 1.61 #1)
	id 16AtNS-0005d8-00; Mon, 3 Dec 2001 08:43:22 -0500
Received: from linden.nesc.epa.gov ([134.67.64.25] helo=nesc.epa.gov)
	by relay.eticomm.net with esmtp (Exim 3.33 #2)
	id 16AtNR-0002PS-00
	for camm@enhanced.com; Mon, 03 Dec 2001 08:43:21 -0500
Received: from epa.gov (yew.nesc.epa.gov [134.67.64.48])
	by nesc.epa.gov (8.9.3+Sun/8.9.1) with ESMTP id IAA01538
	for <camm@enhanced.com>; Mon, 3 Dec 2001 08:42:42 -0500 (EST)
Sender: dle@nesc.epa.gov
Message-ID: <3C0B8152.6CDAF8BD@epa.gov>
X-Mailer: Mozilla 4.75C-SGI [en] (X11; I; IRIX 6.5 IP32)
X-Accept-Language: en
MIME-Version: 1.0
References: <004701c17372$2a3580e0$2fee80ac@compaq> <3C025704.86683917@epa.gov>
	 <544rndhvce.fsf@intech19.enhanced.com> <3C07A61C.57A40172@epa.gov> <547ks7kft4.fsf@intech19.enhanced.com>
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-UIDL: b458a850136eaa1c731faa8144f7d567
Lines: 57
Xref: intech19.enhanced.com mail.camm:27531

Camm:

If you only have a Fortran 77 compiler then you won't be able to use the
Fortran 90 intrinsic functions EPSILON and TINY.  You will need to use
the calls to SLAMCH/DLAMCH which appear in the comments of the code I
sent, and remove the declarations of EPSILON and TINY from the INTRINSIC
line.

Should you decide to use these versions, you would want to put the
LAPACK auxiliary routines xLASSQ in LAPACK/SRC and the BLAS routines
xNRM2 in LAPACK/BLAS/SRC.

   --Ed

Camm Maguire wrote:
> 
> Sorry to bother you again -- one other item.  I'm having a bit of
> trouble compiling the lassq with g77:
> 
> f77 -pipe -c -O6 -fomit-frame-pointer  -fPIC classq.f
> classq.f: In subroutine `classq':
> classq.f:63: warning:
>          INTRINSIC ABS, EPSILON, MAX, REAL, TINY
>                         ^
> Reference to unimplemented intrinsic `EPSILON' at (^) (assumed EXTERNAL)
> classq.f:63:
>          INTRINSIC ABS, EPSILON, MAX, REAL, TINY
>                         ^
> Invalid declaration of or reference to symbol `epsilon' at (^) [initially seen at (^)]
> classq.f:63: warning:
>          INTRINSIC ABS, EPSILON, MAX, REAL, TINY
>                                             ^
> Reference to unimplemented intrinsic `TINY' at (^) (assumed EXTERNAL)
> classq.f:63:
>          INTRINSIC ABS, EPSILON, MAX, REAL, TINY
>                                             ^
> Invalid declaration of or reference to symbol `tiny' at (^) [initially seen at (^)]
> make: *** [classq.o] Error 1
> 
> Have I merely put these files in the wrong place?  Or does your
> fortran compiler define more intrinsics than g77?  Can I hardcode
> these values from the lapack lamch output?
> 
> Take care,
> --
> Camm Maguire                                            camm@enhanced.com
> ==========================================================================
> "The earth is but one country, and mankind its citizens."  --  Baha'u'llah

----------------------------------------------------------------
Ed Anderson
Scientific Applications Consultant
Lockheed Martin Technology Services (contractor to the U.S. EPA)
Phone: 919-541-0299
mailto:Anderson.Edward@epa.gov

=============================================================================

From: Edward Anderson <Anderson.Edward@epa.gov>
Subject: Re: New Debian maintainer
To: Camm Maguire <camm@enhanced.com>
Date: Tue, 04 Dec 2001 09:00:44 -0500
Organization: Lockheed Martin (contractor to the U.S. EPA)
Received: from localhost [127.0.0.1] (root)
	by intech5.enhanced.com with esmtp (Exim 3.12 #1 (Debian))
	id 16BGBM-0000Ti-00; Tue, 04 Dec 2001 09:04:24 -0500
Received: from 204.213.252.11
	by localhost with POP3 (fetchmail-5.3.3)
	for camm@enhanced.com (multi-drop); Tue, 04 Dec 2001 09:04:24 -0500 (EST)
Received: from mail.eticomm.net [204.213.252.17] 
	by ux1.cyberenet.net with esmtp (Exim 1.61 #1)
	id 16BG8K-0001XT-00; Tue, 4 Dec 2001 09:01:16 -0500
Received: from linden.nesc.epa.gov ([134.67.64.25] helo=nesc.epa.gov)
	by relay.eticomm.net with esmtp (Exim 3.33 #2)
	id 16BG8K-000FX3-00
	for camm@enhanced.com; Tue, 04 Dec 2001 09:01:16 -0500
Received: from epa.gov (yew.nesc.epa.gov [134.67.64.48])
	by nesc.epa.gov (8.9.3+Sun/8.9.1) with ESMTP id JAA07649
	for <camm@enhanced.com>; Tue, 4 Dec 2001 09:00:44 -0500 (EST)
Sender: dle@nesc.epa.gov
Message-ID: <3C0CD70C.EA958B8C@epa.gov>
X-Mailer: Mozilla 4.75C-SGI [en] (X11; I; IRIX 6.5 IP32)
X-Accept-Language: en
MIME-Version: 1.0
References: <004701c17372$2a3580e0$2fee80ac@compaq> <3C025704.86683917@epa.gov>
	 <544rndhvce.fsf@intech19.enhanced.com> <3C07A61C.57A40172@epa.gov>
	 <547ks7kft4.fsf@intech19.enhanced.com> <3C0B8152.6CDAF8BD@epa.gov> <54oflgyq59.fsf@intech19.enhanced.com>
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-UIDL: adfa4279f91ebf2369b8aaef02ca151f
Lines: 23
Xref: intech19.enhanced.com mail.camm:27561

Camm,

There's some danger in continuing in this vein because you'll end up
with your own version of LAPACK that differs from every other one out
there.  But that's probably not so unusual for a software installation.

You may be able to fix some bad test ratios in the symmetric eigenvalue
driver routines by adjusting the value of "FUDGE" in sstebz/dstebz.  As
the name implies, this was a "fudge factor" and it is adjustable.  I
increased it from 2.0 to 2.1 for the CRAY T3E, but I heard from someone
else (can't find the mail now) that they had set it even higher, like
2.5.  Give it a whirl and see what happens.

   --Ed

----------------------------------------------------------------
Ed Anderson
Scientific Applications Consultant
Lockheed Martin Technology Services (contractor to the U.S. EPA)
Phone: 919-541-0299
mailto:Anderson.Edward@epa.gov


=============================================================================
From: Edward Anderson <Anderson.Edward@epa.gov>
Subject: Re: New Debian maintainer
To: Camm Maguire <camm@enhanced.com>
CC: Susan Blackford <susan@cs.utk.edu>
Date: Wed, 05 Dec 2001 16:27:32 -0500
Organization: Lockheed Martin (contractor to the U.S. EPA)
Received: from localhost [127.0.0.1] (root)
	by intech5.enhanced.com with esmtp (Exim 3.12 #1 (Debian))
	id 16Bjcx-0002Uh-00; Wed, 05 Dec 2001 16:30:51 -0500
Received: from 204.213.252.11
	by localhost with POP3 (fetchmail-5.3.3)
	for camm@enhanced.com (multi-drop); Wed, 05 Dec 2001 16:30:51 -0500 (EST)
Received: from mail.eticomm.net [204.213.252.17] 
	by ux1.cyberenet.net with esmtp (Exim 1.61 #1)
	id 16BjaG-0005He-00; Wed, 5 Dec 2001 16:28:04 -0500
Received: from linden.nesc.epa.gov ([134.67.64.25] helo=nesc.epa.gov)
	by relay.eticomm.net with esmtp (Exim 3.33 #2)
	id 16BjaF-000IIY-00
	for camm@enhanced.com; Wed, 05 Dec 2001 16:28:03 -0500
Received: from epa.gov (yew.nesc.epa.gov [134.67.64.48])
	by nesc.epa.gov (8.9.3+Sun/8.9.1) with ESMTP id QAA18500;
	Wed, 5 Dec 2001 16:27:32 -0500 (EST)
Sender: dle@nesc.epa.gov
Message-ID: <3C0E9144.3035D152@epa.gov>
X-Mailer: Mozilla 4.75C-SGI [en] (X11; I; IRIX 6.5 IP32)
X-Accept-Language: en
MIME-Version: 1.0
References: <004701c17372$2a3580e0$2fee80ac@compaq> <3C025704.86683917@epa.gov>
	 <544rndhvce.fsf@intech19.enhanced.com> <3C07A61C.57A40172@epa.gov>
	 <547ks7kft4.fsf@intech19.enhanced.com> <3C0B8152.6CDAF8BD@epa.gov>
	 <54oflgyq59.fsf@intech19.enhanced.com> <3C0CD70C.EA958B8C@epa.gov> <54vgflms1a.fsf@intech19.enhanced.com>
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-UIDL: 7c86af4c1b5cd2c960fef3c9e2448126
Lines: 68
Xref: intech19.enhanced.com mail.camm:27607

Camm Maguire wrote:
> 
> Greetings, and thank you again for the suggestion.  I saw the
> adjustment to 2.1, but changing it a bit all the way up to 3.5 made no
> difference at all in the test results.  I don't know what this means.
> 
> I'd also like to ask you about the significance of the errors, and
> which set is 'preferable'.  Are routine errors worse than driver
> errors?  Why did the complex driver errors get so much larger in
> magnitude with your blas changes? (everything else seems to have
> decreased.)  What effect in practice will the magnitudes of the errors
> seen in both sets have on typical library use?  And lastly, is it known
> how these errors got introduced into the code in the last year? (1999
> 3.0 doesn't have them.)
> 

Camm:

With a few exceptions, all the mathematics of LAPACK is contained in the
computational routines.  If you get a failure in a driver routine when
all the computational routines passed their tests, it is usually because
one path through the driver routines didn't agree with another path
through the driver routines, and the writer of the test code thought
that they should.  I regard all the errors as equal in importance, but
many of the eigensystem tests are not very well documented.

There are a lot of calculations in LAPACK that are sensitive to the
scaling and even the order of operations.  Also, the LAPACK test code
deliberately generates some numerically sensitive test problems to
exercise parts of the code.  Sometimes a change in the scaling will make
a particular test ratio disappear, while creating a bad test ratio
somewhere else.  It's hard to say which method is "better" without more
analysis.  I've managed to get all except the xgd tests to pass on a
CRAY PVP, CRAY MPP, and IBM SP, but my set of changes is rather large
and not limited to numerical accuracy (some are to improve performance).

In my experience, test ratios under 1000 or so are usually not that
serious.  Most of the test ratios are scaled so that an order of
magnitude is a lost decimal place of accuracy, and the thresholds are
set to about 50.  So, if your test ratio were 1000, you would have lost
about 3 places of accuracy -- a lot in single precision, but probably in
the noise in double precision.  If you were concerned about the accuracy
of a particular solution in the context of an application, LAPACK has
error bounds and condition number information built into the "expert"
driver routines that may offer some guidance about what to expect.

Your best bet as the installer of LAPACK would be to document the
failures you currently see, ask that they be posted in the LAPACK
release notes, and wait for something better to come along.  It will
also give you a baseline for comparison if and when there is a new
LAPACK release.  Just by looking at the error messages that were
generated, you've already done more than some library developers I know!

I'll put you on my list of people to notify when my (totally unsupported
and unauthorized) patch for the IBM SP is available.  It's been useful
for me to see that some set of users still needs Fortran 77
compatibility.

   --Ed

----------------------------------------------------------------
Ed Anderson
Scientific Applications Consultant
Lockheed Martin Technology Services (contractor to the U.S. EPA)
Phone: 919-541-0299
mailto:Anderson.Edward@epa.gov


=============================================================================

 -- Camm Maguire <camm@enhanced.com>, Tue, 29 Jan 2002 11:42:34 -0500
